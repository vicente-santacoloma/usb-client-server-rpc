	
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>


#include "LaCadena.h"
#include "Inventario.h"
#include "Proveedor.h"
#include "Pedido.h"

/*
 * Investigando en interner leimos que una cosa que se podria hacer para
 * "mejorar UPD" es mandar datagramas que no sean fragmentados porque 
 * podrian haber arquitecturas que no me manejaran fragmentacion. Por lo
 * que recomendaron un tamano maximo de 1440, esto se debe a los siguientes 
 * calculos:
 * El header de IP es >= 20 bytes, pero en la mayoria de los casos es de 20 
 * y el header de UDP es de 8 bytes. Por lo que no deja 1500 - 28 = 1472 bytes
 * para la data.
 */
#define MAX_SIZE_DATA_DATAGRAM 1472

#define BUFFER_SIZE 10000

/**
 * Imprimer un mensaje de error y aborta el programa.
 *
 * @param msg el mensaje a imprimir.
 * @return nada
 */
void error(const char *msg) {
  perror(msg);
  exit(0);
}

/**
 * Calcula la diferencia de precio de dos inventarios.

 * @param a un apuntador a inventario.
 * @param b un apuntador a inventario.
 * @return la diferencia de precios de dos inventarios.
 */
int compare (const void * a, const void * b) {

  float e1 = (*((Inventario **)a))->precio;
  float e2 = (*((Inventario **)b))->precio;
  if(e1 < e2)
    return -1;
  else if(e1 > e2)
    return 1;
  return 0;
}

/**
 * Carga los parametros entrada del programa cliente en las variables 
 * correspondientes.
 *
 * @param argc numero de argumentos recibidos 
 * @param argv arreglo de strings conteniendo los parametros de entrada del 
 * programa.
 * En la primera posici√≥n debe estar ordenes que es el nombre del programa.
 * @param archivoPedidos el string donde se guardara el nombre de archivo que 
 * contiene los pedidos a cargar.
 * @param archivoProveedores el string donde se guardara el nombre de archivo 
 * que contiene los proveedores a cargar.
 * @param nivel funcion que corresponde a la operacion a realizar.
 * @return true si las opciones son correctas, falso en caso contrario.
 */
int cargarParametros(int argc, char *argv[], char ** archivoProveedores, 
                     int * puerto) {
  int b [2] = {FALSE, FALSE};
  int k = 1;
  if(argc != 5)
    return FALSE;
  while(k < argc) {
    if(argv[k][0] == '-') {
      switch(argv[k][1]) {
        case 'd':
          if(b[0])
            return FALSE;
          b[0] = TRUE;  
          ++k;          
          *archivoProveedores = argv[k];
          break;
        case 'p':
          if(b[1])
            return FALSE;
          b[1] = TRUE;
          ++k;
          *puerto = atoi(argv[k]);
          break;
        default:
          return FALSE;
      } 
    } else
        return FALSE;
    ++k;
  }
  return TRUE;
}

/**
 * Selecciona el pedido a realizar de entre todos los inventarios enviados por
 * los proveedores tomando el que tenga el menor precio (En caso de que varios 
 * tengan el mismo precio se toma el primero por defecto). Si no se logra 
 * satisfacer la demanda se solicitara lo disponible y el restante quedara como
 * pedidos faltantes.
 *
 * @param inventariosProveedores vector que contiene todos los inventarios
 * enviados por los proveedores.
 * @param inventariosProveedoresSolicitud vector donde se guardaran los vectores
 * de inventarios por proveedores.
 * @param inventariosProveedoresFaltantes string donde se concatenaran los productos
 * faltantes junto con sus cantidades faltantes.
 * @return nada.
 */
void construirSolicitudesPorProveedor(Vector * inventariosProveedores, Vector ** inventariosProveedoresSolicitud, char **inventariosProveedoresFaltantes) {

  //basico(inventariosProveedores);
  Vector * inventariosProveedor = NULL;
  Vector * inventariosPedidos = NULL;
  Vector * inventariosPedido = NULL;
  Vector * inventariosSolicitud = NULL;
  Vector * inventariosProveedorSolicitud = NULL; 

  int sizePedidos = size(pedidos);
  int sizeProveedores = size(proveedores);
  int sizeinventariosSolicitud;
  int sizeInventariosProveedor;
  int sizeInventariosPedido;
  
  char convert [33];

  Inventario * inventario = NULL;
//   Inventario * inventarioFaltante = NULL;
  Pedido * pedido = NULL;
  Proveedor * proveedor = NULL;
  int i, j, k;

  create(&inventariosPedidos);
  create(&inventariosSolicitud);
  
  for(i = 0; i < sizePedidos; ++i) {
    pedido = (Pedido *)at(pedidos, i);
    inventariosPedido = NULL;
    create(&inventariosPedido);
    for(j = 0; j < sizeProveedores; ++j) {
      inventariosProveedor = (Vector *)at(inventariosProveedores, j);
      sizeInventariosProveedor = size(inventariosProveedor);
      for(k = 0; k < sizeInventariosProveedor; ++k) {
        inventario = (Inventario *)at(inventariosProveedor, k);
        if(strcmp(inventario->producto, pedido->producto) == 0) {
          push_back(&inventariosPedido, inventario);
          break;          
        }
      }
    }
    push_back(&inventariosPedidos, inventariosPedido);
  }

  Inventario ** inventariosPedidoArreglo;

  for(i = 0; i < sizePedidos; ++i) {
    inventariosPedido = (Vector *)at(inventariosPedidos, i);
    if(!empty(inventariosPedido)) {
      inventariosPedidoArreglo = (Inventario **)begin(inventariosPedido);
      qsort(inventariosPedidoArreglo, size(inventariosPedido), sizeof(Inventario *), compare);
    }
  }

  int cantidadSolicitada = 0;
  int cantidadDisponible = 0;
  
  for(i = 0; i < sizePedidos; ++i) {

    pedido = (Pedido *)at(pedidos, i);
    cantidadSolicitada = pedido->cantidad;
    inventariosPedido = (Vector *)at(inventariosPedidos, i);
    sizeInventariosPedido = size(inventariosPedido);

    for(j = 0; j < sizeInventariosPedido; ++j) {

      inventario = (Inventario *)at(inventariosPedido, j);
      cantidadDisponible = inventario->cantidad;
      push_back(&inventariosSolicitud, inventario);
      if(cantidadDisponible >= cantidadSolicitada) {
        inventario->cantidad = cantidadSolicitada;
        cantidadSolicitada = 0;
        break;
      } else {
        cantidadSolicitada -= cantidadDisponible;  
      }
    }
    if(cantidadSolicitada != 0) {
      strcat(*inventariosProveedoresFaltantes, pedido -> producto);
      strcat(*inventariosProveedoresFaltantes, "&");
      sprintf(convert, "%d", cantidadSolicitada);
      strcat(*inventariosProveedoresFaltantes, convert);
      strcat(*inventariosProveedoresFaltantes,"&");
    }      
  }

  sizeinventariosSolicitud = size(inventariosSolicitud);

  Vector * v;

  for(i = 0; i < sizePedidos; ++i) {
    v = (Vector *)at(inventariosPedidos, i);
    free(v->array);
    free(v);
  }
  free(inventariosPedidos->array);
  free(inventariosPedidos);

  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores, i);
    inventariosProveedorSolicitud = NULL;
    create(&inventariosProveedorSolicitud); 
    for(j = 0; j < sizeinventariosSolicitud; ++j) {
      inventario = (Inventario *)at(inventariosSolicitud, j);
      if(strcmp(proveedor->nombre, (inventario->proveedor)->nombre) == 0)
        push_back(&inventariosProveedorSolicitud, inventario);
    }
    push_back(inventariosProveedoresSolicitud, inventariosProveedorSolicitud);
  }
  free(inventariosSolicitud->array);
  free(inventariosSolicitud);

}

/**
 * Realiza una peticion a todos los proveedores, la cual contiene
 * el nombre de varios productos, recibiendo de cada uno el inventario 
 * asociado a cada producto.
 * Selecciona el inventario deseado de los enviados por todos los
 * proveedores y posteriormente se le envia a cada uno.
 * Todo los anterior los hace basandose en el protocolo de comunicacion
 * RPC.
 * @param inventariosProveedoresSolicitud String que guarda todos los pedidos
 * solicitados a todos los proveedores. Posee el formato nombreProducto&nombreProveedor&
 * cantidadSolicitada&precio&nobmreProducto&...
 * @param inventariosProveedoresSolicitud String que guarda todos los pedidos
 * faltantes. Posee el formato nombreProducto&cantidadFaltante&nobmreProducto&...
 * @return nada.
 */
void la_cadena_1(char *inventariosProveedoresSolicitud, char *inventariosProveedoresFaltantes)
{
  int i;
  int j;
  CLIENT *clnt;
  char * *result_1;
  char * obtenerinventario_1_arg;
  int  *result_2;
  char * realizar_pedido_productos_1_arg;
  char *host;
  char solicitudString[BUFFER_SIZE];
  char convert [33];
  Proveedor * proveedor;
  Vector * inventariosProveedores;
  Vector * vectorInventariosProveedoresSolicitud;
  Vector * inventariosProveedorSolicitud; //Vector que contiene los productos que van
					   // a ser pedidos en el segundo servicio.
  int sizeProveedores;
  int sizeInventariosProveedorSolicitud;
	
  sizeProveedores = size(proveedores);
  create(&inventariosProveedores);
	
  /**
   * Para cada proveedor cargo su inventario con el servicio cargarinventario_1
   * y ejecuto el servicio obtenerinventario_1.
   * 
   */
  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores,i);
    host = proveedor->dns;
	  
    clnt = clnt_create (host, LA_CADENA, LA_CADENA_V1, "tcp");
    if (clnt == NULL) {
      clnt_pcreateerror (host);
      exit (1);
    }
	  
    obtenerinventario_1_arg = pedidosString;
	  
    result_1 = obtenerinventario_1(&obtenerinventario_1_arg, clnt);
    if (result_1 == (char **) NULL) {
      clnt_perror (clnt, "call failed");
    }
	  
    push_back(&inventariosProveedores, generarInventario(*(result_1), proveedor));
    clnt_destroy (clnt);
  }
	
  /* 
   * Se procede a formar un vector que contendra vectores referentes
   * a los pedidos definitivos que se le realizara a cada proveedor.
   */	
  vectorInventariosProveedoresSolicitud = NULL;
  create(&vectorInventariosProveedoresSolicitud);
  bzero(inventariosProveedoresSolicitud, BUFFER_SIZE);
  bzero(inventariosProveedoresFaltantes, BUFFER_SIZE);
  
  construirSolicitudesPorProveedor(inventariosProveedores, 
				    &vectorInventariosProveedoresSolicitud, 
				    &inventariosProveedoresFaltantes);
	
  Inventario * inventario;

	
  create(&inventariosProveedorSolicitud);
  bzero(inventariosProveedoresSolicitud, BUFFER_SIZE);
	
  /* 
   * Para cada proveedor ejecuto el servicio realizar_pedido_productos_1.
   */
  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores,i);
    inventariosProveedorSolicitud = (Vector *)at(vectorInventariosProveedoresSolicitud, i);
    
    if(!empty(vectorInventariosProveedoresSolicitud)) {
      host = proveedor->dns;
	    
      clnt = clnt_create (host, LA_CADENA, LA_CADENA_V1, "tcp");
      if (clnt == NULL) {
      	clnt_pcreateerror (host);
      	exit (1);
      }
	    
      sizeInventariosProveedorSolicitud = size(inventariosProveedorSolicitud);
	    
      //Construyo el String que va a ser pasado como parametro
      bzero(solicitudString, BUFFER_SIZE);
      for(j = 0; j < sizeInventariosProveedorSolicitud; ++j) {
      	inventario = (Inventario *)at(inventariosProveedorSolicitud, j);
      	strcat(solicitudString, inventario->producto);
      	strcat(solicitudString, "&");
      	sprintf(convert,"%d", inventario->cantidad);
      	strcat(solicitudString, convert);
      	strcat(solicitudString, "&");
      	      
      	strcat(inventariosProveedoresSolicitud, inventario->producto);
      	strcat(inventariosProveedoresSolicitud, "&");
      	strcat(inventariosProveedoresSolicitud, (inventario->proveedor)->nombre);
      	strcat(inventariosProveedoresSolicitud, "&");
      	sprintf(convert,"%d", inventario->cantidad);
      	strcat(inventariosProveedoresSolicitud, convert);
        strcat(inventariosProveedoresSolicitud, "&");
        sprintf(convert,"%f", inventario->precio);
        strcat(inventariosProveedoresSolicitud, convert);
      	strcat(inventariosProveedoresSolicitud, "&");
      }
      
      realizar_pedido_productos_1_arg = solicitudString;
      result_2 = realizar_pedido_productos_1(&realizar_pedido_productos_1_arg, clnt);
      if (result_2 == (int *) NULL) {
	      clnt_perror (clnt, "call failed");
      }
	    
      if(*(result_2) != 1){
      	error("La operacion no pudo ser completada\n");
      	exit(1);
      }
      clnt_destroy (clnt);
    }
  }
	
  /*
   * Liberar espacio usado por vectores del primer servicio.
   */
  Vector * inventariosProveedor;
  j=0;
  int sizeInventariosProveedor;

  for(i = 0; i < sizeProveedores; ++i) {
    inventariosProveedor = (Vector *)at(inventariosProveedores, i);
    sizeInventariosProveedor = size(inventariosProveedor);
    for(j = 0; j < sizeInventariosProveedor; ++j) {
      inventario = (Inventario *)at(inventariosProveedor, j);
      free(inventario->producto);
      free(inventario);
    }
    free(inventariosProveedor->array);
    free(inventariosProveedor);    
  }
  
  free(inventariosProveedores->array);
  free(inventariosProveedores);
  // Hasta aqui llega el codigo para liberar memoria

  //Liberar espacio usado por vectores del segundo servicio.
  for(i = 0; i < sizeProveedores; ++i) {
    inventariosProveedorSolicitud = (Vector *)at(vectorInventariosProveedoresSolicitud, i);
    free(inventariosProveedorSolicitud->array);
    free(inventariosProveedorSolicitud);
  }
  free(vectorInventariosProveedoresSolicitud->array);
  free(vectorInventariosProveedoresSolicitud);
  //Aqui termina el codigo para liberar memoria
	
}

/**
 * Programa principal. A lo largo del main se realizan las comunicacion UPD
 * necesarias para que el intermediario y el cliente intercambien informacion.
 *
 * @param argc numero de argumentos recibidos.
 * @param argv arreglo de strings conteniendo los parametros de entrada del 
 * programa.
 * En la primera posici√≥n debe estar ordenes que es el nombre del programa.
 * @return 0 si no hubieron errores durante la ejecucion del programa, 1 en 
 * caso contrario.
 */
int main (int argc, char *argv[])
{
  //Cargo los parametros
  char * archivoProveedores;
  int puerto;
  int sockfd; 
  int addr_len, numbytes;
  char buffer[BUFFER_SIZE];
  char acumuladorBuffer[BUFFER_SIZE];
  char convert[33];
  int acumulador;
  int total_A_Recibir;
  char inventariosProveedoresSolicitud[BUFFER_SIZE];
  char inventariosProveedoresFaltantes[BUFFER_SIZE];
  char resp; //Variable que tiene el valor de la respuesta
	
  if(!cargarParametros(argc, argv, &archivoProveedores, &puerto)) {
    printf("Formato de entrada invalido\n");
    exit(1);
  }

  create(&proveedores);
  create(&pedidos);
 
  cargarProveedores(archivoProveedores);
  
  /*
   * Se recibe el datagrama enviado por el cliente con los pedidos con sus
   * respectivas cantidades.
   */
  struct sockaddr_in my_addr; /* direccion IP y numero de puerto local */
  struct sockaddr_in their_addr; /* direccion IP y numero de puerto del cliente */
  /* addr_len contendra el tamanio de la estructura sockadd_in y numbytes el
   * numero de bytes recibidos
   */
	 
  if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
    perror("socket");
    exit(1);
  }
	 
  my_addr.sin_family = AF_INET;
  my_addr.sin_port = htons(puerto);
  my_addr.sin_addr.s_addr = INADDR_ANY;
  bzero(&(my_addr.sin_zero), 8); 
	 
  if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1) {
    perror("bind");
    exit(1);
  }
  resp = '0'; 
	
  while(1){
	  
	//------------------------RECEPCION  DE PEDIDOS-----------------------------//
    printf("\n------------------------RECEPCION  DE PEDIDOS-----------------------------\n");
    addr_len = sizeof(struct sockaddr);
    if ((numbytes=recvfrom(sockfd, buffer, BUFFER_SIZE, 0, 
			    (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
      perror("recvfrom");
      exit(1);
    }
    
    ///Envio de respuesta de recepcion.
    if ((numbytes=sendto(sockfd, &resp, sizeof(char), 0,
			  (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
      perror("sendto");
      exit(1);
    }
    ///
    
    total_A_Recibir = atoi(buffer);
    printf("El total a recibir es de %d bytes\n\n", total_A_Recibir);
	
    /**
     * El cliente solo va a mandar datagramas UDP con tamano de datos maximo de 1472 bytes,
     * por lo que si los pedidos superan ese tamano se mandaran varios datagramas.
     * El do-while de abajo se encarga de concatenar los datos de los UDP en la
     * variable acumuladorBuffer para que despues sirva para crear el vector de pedidos
     * y la variable pedidosString.
     */
    acumulador = 0;
    bzero(acumuladorBuffer,BUFFER_SIZE);
    do {
      bzero(buffer,BUFFER_SIZE);

      if ((numbytes=recvfrom(sockfd, buffer, BUFFER_SIZE, 0, 
			      (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
      }
		  
      ///Envio de respuesta de recepcion.
      if ((numbytes=sendto(sockfd, &resp, sizeof(char), 0,
			    (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
      }
      ///
		  
      strcat(acumuladorBuffer, buffer);
      acumulador += strlen(buffer); 
      printf("LO RECIBIDO HASTA LOS MOMENTOS ES:\n%s\nEl acumulador del buffer tiene tamano %d\n",acumuladorBuffer, acumulador);
		  
    } while ( acumulador < total_A_Recibir );
    // Aqui concluye la primera comunicacion cliente-intermediario
	
	
    /*
     * Se inicializa la variable global pedidosString y
     * el vector de pedidos.
     */
    pedidos = generarPedido(acumuladorBuffer);
    printf("\nPEDIDOS RECIBIDOS POR EL CLIENTE:\n%s\n",pedidosString); 
		
		
    //----------------LLAMADA A PROCEDIMIENTO QUE LLAMA LOS SERVICIOS RPC-----------------------/
    printf("\n-------LLAMADA A PROCEDIMIENTO QUE LLAMA LOS SERVICIOS RPC--------\n");
    la_cadena_1 (inventariosProveedoresSolicitud, inventariosProveedoresFaltantes);
		
    printf("INVENTARIO SOLICUTADO\n%s\n", inventariosProveedoresSolicitud);
    printf("INVENTARIO FALTANTE\n%s\n", inventariosProveedoresFaltantes);
    
    printf("Las operacion con RPC fueron completadas con exito\n");
		
    //-----------------------------ENVIO DE SOLICITUDES HECHAS ------------------------------//
		
    printf("\n-------------ENVIO DE SOLICITUDES HECHAS ---------------\n");
    /** Envio el tamano total del string que contiene todas las solicitudes hechas*/
    sprintf(convert,"%zd", strlen(inventariosProveedoresSolicitud));
    if ((numbytes=sendto(sockfd, convert, strlen(convert), 0,
			  (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
      perror("sendto");
      exit(1);
    }
		
    ///Recibo de la respuesta de recibo.
    if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			    (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
      perror("recvfrom");
      exit(1);
    }
    if(resp!='0'){
      perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
      exit(1);
    }
    ///
		
    printf("Los pedidos solicitados a enviar son\n%s\nCon un tamano de %s bytes\n\n", inventariosProveedoresSolicitud, convert);
		      
    /**
     * Por la explicacion del primer comentario de este archivo (el de MAX_SISE_DATA_DATAGRAM)
     * debemos mandar datagramas con tamano de dato de 1472 bytes, por lo que se debe descomponer
     * el string de pedidos en varios pedazos para ser enviados a traves del socket, y eso se hace
     * a continuacion.
     */
		
    while(strlen(inventariosProveedoresSolicitud) > MAX_SIZE_DATA_DATAGRAM) {
      char *solicitudesRestantes;
      int tam_restante;
		  
      tam_restante = strlen(inventariosProveedoresSolicitud) - MAX_SIZE_DATA_DATAGRAM+1;
      solicitudesRestantes = (char *)malloc(tam_restante);
			if(solicitudesRestantes==NULL){
				perror("malloc");
				exit(1);
			}
		  
      strcpy(solicitudesRestantes, &inventariosProveedoresSolicitud[MAX_SIZE_DATA_DATAGRAM]);
      solicitudesRestantes[strlen(solicitudesRestantes)] = '\0';
      inventariosProveedoresSolicitud[MAX_SIZE_DATA_DATAGRAM] = '\0';
		  
      if ((numbytes=sendto(sockfd, inventariosProveedoresSolicitud, strlen(inventariosProveedoresSolicitud), 0,
			    (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
      }
		  
      ///Recibo de la respuesta de recibo.
      if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			      (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
      }
      if(resp!='0'){
        perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
        exit(1);
      }
      ///
		  
      printf("STRING MANDADO\n%s\n", inventariosProveedoresSolicitud);
		  
      strcpy(inventariosProveedoresSolicitud, solicitudesRestantes);
      inventariosProveedoresSolicitud[strlen(solicitudesRestantes)] = '\0';
      free(solicitudesRestantes);
		  
    }
		
    if ((numbytes=sendto(sockfd, inventariosProveedoresSolicitud, strlen(inventariosProveedoresSolicitud), 0,
			  (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
      perror("sendto");
      exit(1);
    }
		
    ///Recibo de la respuesta de recibo.
    if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			    (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
      perror("recvfrom");
      exit(1);
    }
    if(resp!='0'){
      perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
      exit(1);
    }
    ///

    printf("STRING MANDADO\n%s\n", inventariosProveedoresSolicitud);
    /** Fin de Envio de datos (SOLICITUDES HECHAS)*/
		
    //-----------------------------ENVIO DE PEDIDOS FALTANTES------------------------------//
	
    printf("\n---------------ENVIO DE PEDIDOS FALTANTES----------------\n");
    /** Envio el tamano total del string que contiene todas las solicitudes hechas*/
    sprintf(convert,"%zd", strlen(inventariosProveedoresFaltantes));
    if ((numbytes=sendto(sockfd, convert, strlen(convert), 0,
			  (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
      perror("sendto");
      exit(1);
    }
		
    ///Recibo de la respuesta de recibo.
    if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			    (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
      perror("recvfrom");
      exit(1);
    }
    if(resp!='0'){
      perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
      exit(1);
    }
    ///
		
    printf("Los pedidos faltantes a enviar son\n%s\nCon un tamano de %s bytes\n\n", inventariosProveedoresFaltantes, convert);
		      
    /**
     * Por la explicacion del primer comentario de este archivo (el de MAX_SISE_DATA_DATAGRAM)
     * debemos mandar datagramas con tamano de dato de 1472 bytes, por lo que se debe descomponer
     * el string de pedidos en varios pedazos para ser enviados a traves del socket, y eso se hace
     * a continuacion.
     */
		
    while(strlen(inventariosProveedoresFaltantes) > MAX_SIZE_DATA_DATAGRAM){
      char *solicitudesRestantes;
      int tam_restante;
      
      tam_restante = strlen(inventariosProveedoresFaltantes) - MAX_SIZE_DATA_DATAGRAM+1;
      solicitudesRestantes = (char *)malloc(tam_restante);
			if(solicitudesRestantes==NULL){
				perror("malloc");
				exit(1);
			}
      
      strcpy(solicitudesRestantes, &inventariosProveedoresFaltantes[MAX_SIZE_DATA_DATAGRAM]);
      solicitudesRestantes[strlen(solicitudesRestantes)] = '\0';
      inventariosProveedoresFaltantes[MAX_SIZE_DATA_DATAGRAM] = '\0';
      
      if ((numbytes=sendto(sockfd, inventariosProveedoresFaltantes, strlen(inventariosProveedoresFaltantes), 0,
			    (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
      }
		  
      ///Recibo de la respuesta de recibo.
      if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			      (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
      }
      if(resp!='0'){
        perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
        exit(1);
      }
      ///
		  
      printf("STRING MANDADO\n%s\n", inventariosProveedoresFaltantes);
		  
      strcpy(inventariosProveedoresFaltantes, solicitudesRestantes);
      inventariosProveedoresFaltantes[strlen(solicitudesRestantes)] = '\0';
      free(solicitudesRestantes);
		  
    }
		
    if ((numbytes=sendto(sockfd, inventariosProveedoresFaltantes, strlen(inventariosProveedoresFaltantes), 0,
			  (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
      perror("sendto");
      exit(1);
    }
		
    ///Recibo de la respuesta de recibo.
    if ((numbytes=recvfrom(sockfd, &resp, sizeof(char), 0, 
			    (struct sockaddr *)&their_addr, (socklen_t *)&addr_len)) == -1) {
      perror("recvfrom");
      exit(1);
    }
    if(resp!='0'){
      perror("ERROR EN ENVIAR TAMANO PEDIDOS\n");
      exit(1);
    }
    ///
		
    printf("STRING MANDADO\n%s\n", inventariosProveedoresFaltantes);
    /** Fin de Envio de datos (SOLICITUDES HECHAS)*/
  }
}
