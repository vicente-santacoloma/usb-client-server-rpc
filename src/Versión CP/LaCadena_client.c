	
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>


#include "LaCadena.h"
#include "Inventario.h"
#include "Proveedor.h"
#include "Pedido.h"


#define BUFFER_SIZE 10000

/**
 * Imprimer un mensaje de error y aborta el programa.
 *
 * @param msg el mensaje a imprimir.
 * @return nada
 */
void error(const char *msg) {
  perror(msg);
  exit(0);
}

/**
 * Calcula la diferencia de precio de dos inventarios.

 * @param a un apuntador a inventario.
 * @param b un apuntador a inventario.
 * @return la diferencia de precios de dos inventarios.
 */
int compare (const void * a, const void * b) {

  float e1 = (*((Inventario **)a))->precio;
  float e2 = (*((Inventario **)b))->precio;
  if(e1 < e2)
    return -1;
  else if(e1 > e2)
    return 1;
  return 0;
}

/**
 * Carga los parametros entrada del programa cliente en las variables 
 * correspondientes.
 *
 * @param argc numero de argumentos recibidos 
 * @param argv arreglo de strings conteniendo los parametros de entrada del 
 * programa.
 * En la primera posición debe estar ordenes que es el nombre del programa.
 * @param archivoPedidos el string donde se guardara el nombre de archivo que 
 * contiene los pedidos a cargar.
 * @param archivoProveedores el string donde se guardara el nombre de archivo 
 * que contiene los proveedores a cargar.
 * @param nivel funcion que corresponde a la operacion a realizar.
 * @return true si las opciones son correctas, falso en caso contrario.
 */
int cargarParametros(int argc, char *argv[], char ** archivoPedidos, 
                                char **archivoProveedores) {

  int b [2] = {FALSE, FALSE};
  int k = 1;
  if(argc != 5)
    return FALSE;
  while(k < argc) {
    if(argv[k][0] == '-') {
      switch(argv[k][1]) {
        case 'd':
          if(b[0])
            return FALSE;
          b[0] = TRUE;
          ++k;          
          *archivoProveedores = argv[k];
          break;
        case 'f':
          if(b[1])
            return FALSE;
          b[1] = TRUE;
          ++k;
          *archivoPedidos = argv[k];
          break;
        default:
          return FALSE;
      } 
    } else
        return FALSE;
    ++k;
  }
  return TRUE;
}

/**
 * Imprime por la salida estandar el reporte correspondiente a la operacion 
 * basica o a la operacion avanzada segun sea el caso. Para este proyecto siempre
 * se realizara la operacion avanzada.
 *
 * @param reporte reporte a imprimir. 'b' corresponde al avanzado y 'a' al
 * avanzado.
 * @param inventariosProveedoresSolicitud vector que contiene los inventarios a
 * solicitar para cada proveedor.
 * @param inventariosProveedoresFaltantes vector que contiene los inventarios
 * faltantes que no pudieron ser satisfechos por los proveedores.
 * @return nada.
 */
void imprimirReporte(char reporte, Vector * inventariosProveedoresSolicitud, Vector * inventariosProveedoresFaltantes) {

  Vector * inventariosProveedorSolicitud;
  int sizeProveedores = size(proveedores);
  int sizePedidos = size(pedidos);
  int sizeInventariosProveedorSolicitud = 0;
  int sizeInventariosProveedoresFaltantes = size(inventariosProveedoresFaltantes);

  Pedido * pedido = NULL;
  Inventario * inventario = NULL;
  int Total = 0;
  int i = 0;
  int j = 0;
  int k = 0;

  printf("\n--------------------------------------------------------------------------------------------\n");
  if(reporte == 'a')
    printf("| PEDIDOS SOLICITADOS                                                                       |\n");
  else
    printf("| CONSULTA                                                                                  |\n");

  printf("---------------------------------------------------------------------------------------------\n");
  printf("| PRODUCTO                       | PROVEEDOR       | PRECIO     | CANTIDAD   | COSTO TOTAL  |\n");
  printf("---------------------------------------------------------------------------------------------\n");
  
  for(i = 0; i < sizePedidos; ++i) {
    pedido = (Pedido *)at(pedidos, i);
    for(j = 0; j < sizeProveedores; ++j) {
      inventariosProveedorSolicitud = (Vector *)at(inventariosProveedoresSolicitud, j);
      sizeInventariosProveedorSolicitud = size(inventariosProveedorSolicitud);
      for(k = 0; k < sizeInventariosProveedorSolicitud; ++k) {
        inventario = (Inventario *)at(inventariosProveedorSolicitud, k); 
        if((strcmp(pedido->producto, inventario->producto) == 0) && (inventario->cantidad > 0)) {
          printf("| %-30s | %-15s | %-10.2f | %-10d | %-12.2f |\n",
          inventario->producto, (inventario->proveedor)->nombre,
          inventario->precio, inventario->cantidad, 
          (inventario->precio)*(inventario->cantidad));
          Total += (inventario->precio)*(inventario->cantidad);
          break;
        }
      }
    }
  }
  printf("---------------------------------------------------------------------------------------------\n");
  printf("| TOTAL                                                                      | %-12d |\n",Total);
  printf("---------------------------------------------------------------------------------------------\n");
  printf("| PEDIDOS FALTANTES                           |\n");
  printf("-----------------------------------------------\n");
  printf("| PRODUCTO                       | CANTIDAD   |\n");
  printf("-----------------------------------------------\n");

  for(i = 0; i < sizeInventariosProveedoresFaltantes; ++i) {
    inventario = (Inventario *)at(inventariosProveedoresFaltantes, i);
    printf("| %-30s | %-10d |\n", inventario->producto, inventario->cantidad);
  }
  printf("-----------------------------------------------\n\n");

}


/**
 * Selecciona el pedido a realizar de entre todos los inventarios enviados por
 * los proveedores tomando el que tenga el menor precio (En caso de que varios 
 * tengan el mismo precio se toma el primero por defecto). Si no se logra 
 * satisfacer la demanda se solicitara lo disponible y el restante quedara como
 * pedidos faltantes.
 *
 * @param inventariosProveedores vector que contiene todos los inventarios
 * enviados por los proveedores.
 * @param inventariosProveedoresSolicitud vector donde se guardaran los vectores
 * de inventarios por proveedores.
 * @param inventariosProveedoresFaltantes vector donde se guardaran los productos
 * faltantes.
 * @return nada.
 */
void construirSolicitudesPorProveedor(Vector * inventariosProveedores, Vector ** inventariosProveedoresSolicitud, Vector **inventariosProveedoresFaltantes) {

  Vector * inventariosProveedor = NULL;
  Vector * inventariosPedidos = NULL;
  Vector * inventariosPedido = NULL;
  Vector * inventariosSolicitud = NULL;
  Vector * inventariosProveedorSolicitud = NULL; 

  int sizePedidos = size(pedidos);
  int sizeProveedores = size(proveedores);
  int sizeinventariosSolicitud;
  int sizeInventariosProveedor;
  int sizeInventariosPedido;

  Inventario * inventario = NULL;
  Inventario * inventarioFaltante = NULL;
  Pedido * pedido = NULL;
  Proveedor * proveedor = NULL;
  int i, j, k;

  create(&inventariosPedidos);
  create(&inventariosSolicitud);
  
  for(i = 0; i < sizePedidos; ++i) {
    pedido = (Pedido *)at(pedidos, i);
    inventariosPedido = NULL;
    create(&inventariosPedido);
    for(j = 0; j < sizeProveedores; ++j) {
      inventariosProveedor = (Vector *)at(inventariosProveedores, j);
      sizeInventariosProveedor = size(inventariosProveedor);
      for(k = 0; k < sizeInventariosProveedor; ++k) {
        inventario = (Inventario *)at(inventariosProveedor, k);
        if(strcmp(inventario->producto, pedido->producto) == 0) {
          push_back(&inventariosPedido, inventario);
          break;          
        }
      }
    }
    push_back(&inventariosPedidos, inventariosPedido);
  }

  Inventario ** inventariosPedidoArreglo;

  for(i = 0; i < sizePedidos; ++i) {
    inventariosPedido = (Vector *)at(inventariosPedidos, i);
    if(!empty(inventariosPedido)) {
      inventariosPedidoArreglo = (Inventario **)begin(inventariosPedido);
      qsort(inventariosPedidoArreglo, size(inventariosPedido), sizeof(Inventario *), compare);
    }
  }

  int cantidadSolicitada = 0;
  int cantidadDisponible = 0;
  
  for(i = 0; i < sizePedidos; ++i) {

    pedido = (Pedido *)at(pedidos, i);
    cantidadSolicitada = pedido->cantidad;
    inventariosPedido = (Vector *)at(inventariosPedidos, i);
    sizeInventariosPedido = size(inventariosPedido);

    for(j = 0; j < sizeInventariosPedido; ++j) {

      inventario = (Inventario *)at(inventariosPedido, j);
      cantidadDisponible = inventario->cantidad;
      push_back(&inventariosSolicitud, inventario);
      if(cantidadDisponible >= cantidadSolicitada) {
        inventario->cantidad = cantidadSolicitada;
        cantidadSolicitada = 0;
        break;
      } else {
        cantidadSolicitada -= cantidadDisponible;  
      }
    }
    if(cantidadSolicitada != 0) {
      inventarioFaltante = (Inventario *)malloc(sizeof(Inventario));
      proveedor = (Proveedor *)malloc(sizeof(Proveedor));
			if((inventarioFaltante==NULL) || (proveedor==NULL)){
				perror("malloc");
				exit(1);
			}
      proveedor->nombre = "";
      inventarioFaltante->producto = (char *)malloc(strlen(pedido->producto));
			if((inventarioFaltante->producto)==NULL){
				perror("malloc");
				exit(1);
			}
      strcpy(inventarioFaltante->producto, pedido->producto);
      inventarioFaltante->proveedor = proveedor;
      inventarioFaltante->cantidad = cantidadSolicitada;
      inventarioFaltante->precio = 0;
      push_back(inventariosProveedoresFaltantes, inventarioFaltante);
    }      
  }

  sizeinventariosSolicitud = size(inventariosSolicitud);

  Vector * v;

  for(i = 0; i < sizePedidos; ++i) {
    v = (Vector *)at(inventariosPedidos, i);
    free(v->array);
    free(v);
  }
  free(inventariosPedidos->array);
  free(inventariosPedidos);

  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores, i);
    inventariosProveedorSolicitud = NULL;
    create(&inventariosProveedorSolicitud); 
    for(j = 0; j < sizeinventariosSolicitud; ++j) {
      inventario = (Inventario *)at(inventariosSolicitud, j);
      if(strcmp(proveedor->nombre, (inventario->proveedor)->nombre) == 0)
        push_back(&inventariosProveedorSolicitud, inventario);
    }
    push_back(inventariosProveedoresSolicitud, inventariosProveedorSolicitud);
  }
  free(inventariosSolicitud->array);
  free(inventariosSolicitud);

  for(i = 0; i < sizeProveedores; ++i) {
  printf("Proveedor: %d\n",i);
  inventariosProveedorSolicitud = (Vector *)at(*inventariosProveedoresSolicitud, i);
  imprimirInventarios((Inventario **)begin(inventariosProveedorSolicitud), size(inventariosProveedorSolicitud));
  printf("\n\n");
  }

  imprimirReporte('a', *inventariosProveedoresSolicitud, *inventariosProveedoresFaltantes);
}

/**
 * Realiza una peticion a todos los proveedores, la cual contiene
 * el nombre de varios productos, recibiendo de cada uno el inventario 
 * asociado a cada producto.
 * Selecciona el inventario deseado de los enviados por todos los
 * proveedores y posteriormente se le envia a cada uno.
 * Todo los anterior los hace basandose en el protocolo de comunicacion
 * RPC.
 *
 * @return nada.
 */
void la_cadena_1() {

  int i;
  int j;
//   int sizeInventariosProveedor;
  CLIENT *clnt;
  char ** result_1;
  char * obtenerinventario_1_arg;
  int  *result_2;
  char * realizar_pedido_productos_1_arg;
  char *host;
  char solicitudString[BUFFER_SIZE];
  char convert [33];
  Proveedor * proveedor;
  Vector * inventariosProveedores;
  Vector * inventariosProveedoresSolicitud;
  Vector * inventariosProveedoresFaltantes;
  Vector * inventariosProveedorSolicitud; // Vector que contiene los productos que 
                                          // a ser pedidos en el segundo servicio.
  int sizeProveedores;
  int sizeInventariosProveedorSolicitud;

  sizeProveedores = size(proveedores);
  create(&inventariosProveedores);
	
  /**
   * Para cada proveedor cargo su inventario con el servicio cargarinventario_1
   * y ejecuto el servicio obtenerinventario_1.
   * 
   */
  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores,i);
    host = proveedor->dns;
    
    clnt = clnt_create (host, LA_CADENA, LA_CADENA_V1, "tcp");
    if (clnt == NULL) {
      clnt_pcreateerror (host);
      exit (1);
    }
    
    obtenerinventario_1_arg = pedidosString;
    
    result_1 = obtenerinventario_1(&obtenerinventario_1_arg, clnt);
    if (result_1 == (char **) NULL) {
      clnt_perror (clnt, "call failed");
    }
    push_back(&inventariosProveedores, generarInventario(*(result_1), proveedor));
    clnt_destroy (clnt);
  }

  /* 
   * Se procede a formar un vector que contendra vectores referentes
   * a los pedidos definitivos que se le realizara a cada proveedor.
   */
  inventariosProveedoresSolicitud = NULL;
  inventariosProveedoresFaltantes = NULL;
  create(&inventariosProveedoresSolicitud);
  create(&inventariosProveedoresFaltantes);
	
  construirSolicitudesPorProveedor(inventariosProveedores, 
					 &inventariosProveedoresSolicitud, 
					 &inventariosProveedoresFaltantes);
	
  Inventario * inventario;
  create(&inventariosProveedorSolicitud);
	
  /* 
   * Para cada proveedor ejecuto el servicio realizar_pedido_productos_1.
   */
  for(i = 0; i < sizeProveedores; ++i) {
    proveedor = (Proveedor *)at(proveedores,i);
    inventariosProveedorSolicitud = (Vector *)at(inventariosProveedoresSolicitud, i);
	  
    if(!empty(inventariosProveedoresSolicitud)) {
      host = proveedor->dns;
      
      clnt = clnt_create (host, LA_CADENA, LA_CADENA_V1, "tcp");
      if (clnt == NULL) {
				clnt_pcreateerror (host);
				exit (1);
      }
	    
			sizeInventariosProveedorSolicitud = size(inventariosProveedorSolicitud);
      
		  //Construyo el String que va a ser pasado como parametro
		  bzero(solicitudString, BUFFER_SIZE);
		  for(j = 0; j < sizeInventariosProveedorSolicitud; ++j) {
				inventario = (Inventario *)at(inventariosProveedorSolicitud, j);
				strcat(solicitudString, inventario->producto);
				strcat(solicitudString, "&");
				sprintf(convert,"%d", inventario->cantidad);
				strcat(solicitudString, convert);
				strcat(solicitudString, "&");
		  }
		  realizar_pedido_productos_1_arg = solicitudString;
		  result_2 = realizar_pedido_productos_1(&realizar_pedido_productos_1_arg, clnt);
		  if (result_2 == (int *) NULL) {
			  clnt_perror (clnt, "call failed");
      }
	    
		  if(*(result_2) != 1) {
				error("La operacion no pudo ser completada\n");
				exit(1);
		  }
		  clnt_destroy (clnt);
    }
  }	

  printf("La solicitud fue completada con exito\n");

  /*
   * Liberar espacio usado por vectores del primer servicio.
   */
  Vector * inventariosProveedor;
  j=0;
  int sizeInventariosProveedor;

  for(i = 0; i < sizeProveedores; ++i) {
    inventariosProveedor = (Vector *)at(inventariosProveedores, i);
    sizeInventariosProveedor = size(inventariosProveedor);
    for(j = 0; j < sizeInventariosProveedor; ++j) {
      inventario = (Inventario *)at(inventariosProveedor, j);
      free(inventario->producto);
      free(inventario);
    }
    free(inventariosProveedor->array);
    free(inventariosProveedor);    
  }
  
  free(inventariosProveedores->array);
  free(inventariosProveedores);
  // Hasta aqui llega el codigo para liberar memoria

  //Liberar espacio usado por vectores del segundo servicio.
  for(i = 0; i < sizeProveedores; ++i) {
    inventariosProveedorSolicitud = (Vector *)at(inventariosProveedoresSolicitud, i);
    free(inventariosProveedorSolicitud->array);
    free(inventariosProveedorSolicitud);
  }
  free(inventariosProveedoresSolicitud->array);
  free(inventariosProveedoresSolicitud);
	clearInventarios(inventariosProveedoresFaltantes);
  //Aqui termina el codigo para liberar memoria
}

/**
 * Programa principal.
 *
 * @param argc numero de argumentos recibidos.
 * @param argv arreglo de strings conteniendo los parametros de entrada del 
 * programa.
 * En la primera posición debe estar ordenes que es el nombre del programa.
 * @return 0 si no hubieron errores durante la ejecucion del programa, 1 en 
 * caso contrario.
 */
int main (int argc, char *argv[]) {

  //Cargo los parametros
  char * archivoPedidos; 
  char * archivoProveedores;

  if(!cargarParametros(argc, argv, &archivoPedidos, &archivoProveedores)) {
    printf("Formato de entrada invalido\n");
    exit(1);
  }

  create(&proveedores);
  create(&pedidos);
  cargarProveedores(archivoProveedores);
  cargarPedidos(archivoPedidos);
	
  la_cadena_1();
  
  clearProveedores(proveedores);
  clearPedidos(pedidos);
  exit (0);
}
